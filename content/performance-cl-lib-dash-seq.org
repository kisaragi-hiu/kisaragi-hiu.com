#+title: Performance comparison between cl-lib, dash, and seq
#+created: 2022-06-05T00:45:51+0900
#+tags[]: emacs-lisp

Caveats: Not compiled

* Conclusions

- In general cl-lib functions are faster than dash.el functions, which are in turn faster than seq.el functions
- dash.el only works with lists
- seq.el is extensible

* Hardware

#+begin_src shell :results output
uname -a
emacs -Q --batch --eval "(princ (format \"Emacs: %s\\n\" emacs-version))"
neofetch cpu gpu memory
#+end_src

#+RESULTS:
: Linux MF-PC 5.15.45-1-lts #1 SMP Mon, 06 Jun 2022 09:19:52 +0000 x86_64 GNU/Linux
: Emacs: 28.1
: cpu: AMD Ryzen 5 2600 (12) @ 3.400GHz
: gpu: AMD ATI Radeon RX 460/560D / Pro 450/455/460/555/555X/560/560X
: memory: 4027MiB / 7958MiB

* Comparisons
- =cl-remove-duplicates=, =-uniq=, =seq-uniq=

  #+begin_src emacs-lisp
  (let ((lst (make-list 1000 8)))
    (k/benchmark-run 10000
      (cl-remove-duplicates lst)
      (-uniq lst)
      (seq-uniq lst)))
  #+end_src

  #+RESULTS:
  |       total | gc-count |            gc-time |
  |-------------+----------+--------------------|
  | 1.226403209 |        0 |                0.0 |
  |  0.93308848 |        4 |  0.716502461000001 |
  | 8.197203663 |       11 | 2.1480029300000005 |

- =cl-some=, =-some=, =seq-some=

  #+begin_src emacs-lisp
  (let ((lst (make-list 1000000 8)))
    (k/benchmark-run 100
      (cl-some #'cl-oddp lst)
      (-some #'cl-oddp lst)
      (seq-some #'cl-oddp lst)))
  #+end_src

  #+RESULTS:
  |             total | gc-count | gc-time |
  |-------------------+----------+---------|
  |       3.790968908 |        0 |     0.0 |
  |       3.496558383 |        0 |     0.0 |
  | 8.371602185999999 |        0 |     0.0 |

- =cl-remove-if-not=, =-filter=, =seq-filter=

  #+begin_src emacs-lisp :lexical t
  (let ((lst (make-list 100000 8)))
    (k/benchmark-run 100
      (cl-remove-if-not #'cl-oddp lst)
      (-filter #'cl-oddp lst)
      (--filter (cl-oddp it) lst)
      (seq-filter #'cl-oddp lst)))
  #+end_src

  #+RESULTS:
  |              total | gc-count |            gc-time |
  |--------------------+----------+--------------------|
  | 1.0588285579999999 |        0 |                0.0 |
  |        0.326594488 |        0 |                0.0 |
  | 44.359205577000004 |       24 |  5.687170252000001 |
  |        1.729285066 |        2 | 0.6450764219999954 |

  Wait what? =-filter= is built on =--filter=, how is =-filter= faster?

  Let me try it compiled:

  #+begin_src emacs-lisp :lexical t
  ;; The `let' doesn't work when using `benchmark-run-compiled' under
  ;; the hood if we wrap it around the entire block.
  ;;
  ;; `make-list' is fast enough that this isn't an issue.
  (k/benchmark-run-compiled 100
    (let ((lst (make-list 100000 8)))
      (cl-remove-if-not #'cl-oddp lst))
    (let ((lst (make-list 100000 8)))
      (-filter #'cl-oddp lst))
    (let ((lst (make-list 100000 8)))
      (--filter (cl-oddp it) lst))
    (let ((lst (make-list 100000 8)))
      (seq-filter #'cl-oddp lst)))
  #+end_src

  #+RESULTS:
  |              total | gc-count |             gc-time |
  |--------------------+----------+---------------------|
  |         1.70707883 |        2 |   0.733798936999996 |
  |        0.905389277 |        1 | 0.40623841200000044 |
  | 1.9187352329999998 |        2 |  0.8186001740000037 |
  |        2.523814185 |        3 |  1.3518518529999994 |

  While this is much less extreme, somehow =--filter= is still slower after accounting for GC time?

* Appendix: Support code

#+begin_src emacs-lisp
(defmacro k/benchmark-run (n &rest forms)
  "Benchmark each of FORMS with `benchmark-run' with N repetitions."
  (declare (indent 1))
  `(list
    '(total gc-count gc-time)
    'hline
    ,@(cl-loop for form in forms
               collect `(benchmark-run ,n
                          ,form))))

(defmacro k/benchmark-run-compiled (n &rest forms)
  "Benchmark each of FORMS with `benchmark-run-compiled' with N repetitions."
  (declare (indent 1))
  `(list
    '(total gc-count gc-time)
    'hline
    ,@(cl-loop for form in forms
               collect `(benchmark-run-compiled ,n
                          ,form))))
#+end_src
